import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from matplotlib import rcParams
from PIL import Image, ImageDraw, ImageFont
import importlib
import common_analys as cmal
import pred
import advice as adv 
import re
from dateparser import parse
from dateparser.search import search_dates
from dateutil.relativedelta import relativedelta
from datetime import datetime
import nest_asyncio
import logging
import os
from io import BytesIO
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputMediaPhoto
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes



def escape_markdown_v2(text):
    escape_chars = r'[\_\\[\]\(\)\~\\>\#\+\-\=\|\{\}\.\!]'
    return re.sub(escape_chars, r'\\\g<0>', text)



def get_season_dates(year: int, season: str):
    seasons = {
        "–≤–µ—Å–Ω–∞": (datetime(year, 3, 1), datetime(year, 5, 31)),
        "–ª–µ—Ç–æ": (datetime(year, 6, 1), datetime(year, 8, 31)),
        "–æ—Å–µ–Ω—å": (datetime(year, 9, 1), datetime(year, 11, 30)),
        "–∑–∏–º–∞": (datetime(year, 12, 1), datetime(year + 1, 2, 28))
    }
    return seasons.get(season.lower())

def parse_period(text: str):
    now = datetime.now()

    if "–ø–æ—Å–ª–µ–¥–Ω–∏–π –º–µ—Å—è—Ü" in text:
        end_date = now
        start_date = now - relativedelta(months=1)
        return start_date, end_date
    
    if "–ø–æ—Å–ª–µ–¥–Ω–∏–π –≥–æ–¥" in text:
        end_date = now
        start_date = now - relativedelta(years=1)
        return start_date, end_date
    
    season_match = re.search(r"(–≤–µ—Å–Ω–∞|–ª–µ—Ç–æ|–æ—Å–µ–Ω—å|–∑–∏–º–∞)\s(\d{4})", text.lower())
    if season_match:
        season, year = season_match.groups()
        year = int(year)
        season_dates = get_season_dates(year, season)
        if season_dates:
            return season_dates

    month_year_match = re.search(r"(\w+)\s(\d{4})", text.lower())
    if month_year_match:
        month_name, year = month_year_match.groups()
        month_date = parse(f"01 {month_name} {year}", settings={'DATE_ORDER': 'DMY'})
        if month_date:
            start_date = month_date
            end_date = month_date + relativedelta(months=1) - relativedelta(days=1)
            return start_date, end_date
        
    range_patterns = [
        r"—Å (\d{1,2}[./]\d{1,2}[./]\d{2,4}) –ø–æ (\d{1,2}[./]\d{1,2}[./]\d{2,4})",
        r"(\d{1,2}[./]\d{1,2}[./]\d{2,4})-(\d{1,2}[./]\d{1,2}[./]\d{2,4})"
    ]
    
    for pattern in range_patterns:
        match = re.search(pattern, text)
        if match:
            start_str, end_str = match.groups()
            start_date = parse(start_str)
            end_date = parse(end_str)
            if start_date and end_date:
                return start_date, end_date

    parsed_dates = search_dates(text, settings={'PREFER_DATES_FROM': 'past'})
    
    if parsed_dates and len(parsed_dates) >= 2:
        return parsed_dates[0][1], parsed_dates[-1][1]
    
    return None, None


nest_asyncio.apply()

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)


#INSERT YOUR OWN BOT TOKEN
TOKEN = ''




async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.info("–ö–æ–º–∞–Ω–¥–∞ /start –≤—ã–∑–≤–∞–Ω–∞")
    welcome_message = "–ü—Ä–∏–≤–µ—Ç, —è —á–∞—Ç-–±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–∂–µ—Ç —Ç–µ–±–µ —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è –≤ —Ç–≤–æ–∏—Ö —Ñ–∏–Ω–∞–Ω—Å–∞—Ö!\n\nüëâ–Ø –º–æ–≥—É –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç–≤–æ–∏ —Ä–∞—Å—Ö–æ–¥—ã –∏ –¥–æ—Ö–æ–¥—ã.\n\nüëâ–î–∞—Ç—å –ø–∞—Ä—É —Å–æ–≤–µ—Ç–æ–≤ –∫–∞–∫ —Å—ç–∫–æ–Ω–æ–º–∏—Ç—å —Ö–æ—Ä–æ—à—É—é —á–∞—Å—Ç—å —Ç–≤–æ–∏—Ö –¥–æ—Ö–æ–¥–æ–≤.\n\nüëâ–ü—Ä–µ–¥—Å–∫–∞–∑–∞—Ç—å —Ç–≤–æ–∏ –±—É–¥—É—â–∏–µ —Ç—Ä–∞—Ç—ã!\n\n–ù–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É, –∏ –º—ã –Ω–∞—á–Ω—ë–º —Ä–∞–±–æ—Ç–∞—Ç—åüëª"
    keyboard = [[InlineKeyboardButton("–ù–∞—á–∞—Ç—å", callback_data='start')]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    message = await update.message.reply_text(welcome_message, reply_markup=reply_markup)
    context.user_data['welcome_message_id'] = message.message_id



async def button_click(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    logger.info(f"Button clicked: {query.data}")

    previous_message_id = context.user_data.get('welcome_message_id')
    if previous_message_id:
        try:
            await query.message.delete()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

    if query.data == 'start':
        caption = (
            "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –ø–æ–∫–∞ –Ω–µ –º–æ–≥—É –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —Ç–≤–æ–∏–º —Ñ–∏–Ω–∞–Ω—Å–∞–º –Ω–∞–ø—Ä—è–º—É—éüòî\n\n"
            "üîÜ–°–∫–∞—á–∞–π, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–≥—Ä—É–∑–∫—É –ø–æ –æ–ø–µ—Ä–∞—Ü–∏—è–º –∏–∑ —Ç–≤–æ–µ–≥–æ –º–æ–±–∏–ª—å–Ω–æ–≥–æ –±–∞–Ω–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ ***csv*** –∏ –ø—Ä–∏—à–ª–∏ –º–Ω–µ —Ñ–∞–π–ª –≤ —á–∞—ÇüîÜ\n\n"
            "–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª —Å–æ —Å–≤–æ–∏–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏:\n"
            "1Ô∏è‚É£–ó–∞–π–¥–∏—Ç–µ –≤ ***–ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –¢\-–±–∞–Ω–∫–∞*** –Ω–∞ —Å–≤–æ—ë–º ***–ü–ö***\n"
            "2Ô∏è‚É£–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤–æ –≤–∫–ª–∞–¥–∫—É ***–û–ø–µ—Ä–∞—Ü–∏–∏***\n"
            "3Ô∏è‚É£–ù–∞–π–¥–∏—Ç–µ —Å—Ç—Ä–µ–ª–æ—á–∫—É –¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏ –í–∞—à–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π\n"
            "4Ô∏è‚É£–°–∫–∞—á–∞–π—Ç–µ —Ñ–∞–π–ª –≤ —Ñ–æ—Ä–º–∞—Ç–µ ***csv***\n"
        )

        photos = [
            InputMediaPhoto(open('inst1.jpg', 'rb'), caption=caption, parse_mode='MarkdownV2'),
            InputMediaPhoto(open('inst2.jpg', 'rb')),
            InputMediaPhoto(open('inst3.jpg', 'rb'))
        ]

        new_message = await query.message.reply_media_group(media=photos)
        context.user_data['previous_message_id'] = new_message[0].message_id


        
async def handle_post_upload(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    logger.info(f"Button clicked: {query.data}")

    previous_message_id = context.user_data.get('previous_message_id')
    if previous_message_id:
        try:
            await query.message.delete()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

    if query.data == 'analytics':
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä–∏–æ–¥, –∑–∞ –∫–æ—Ç–æ—Ä—ã–π –í–∞–º –Ω—É–∂–Ω–∞ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞üëÄ")
        context.user_data['awaiting_date_period'] = True 

    elif query.data == 'save_money':
        df = context.user_data.get('df')
        filtered_data = adv.filter_by_date(df)
        advice_list = adv.advicing(filtered_data)
        advice_text = "\n\n".join(advice_list)
        new_message = await query.message.reply_text(escape_markdown_v2(advice_text), parse_mode='MarkdownV2')

        keyboard = [
            [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='back')],
            [InlineKeyboardButton("–í—ã—Ö–æ–¥", callback_data='exit')]
        ]
        await new_message.reply_text("–ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?", reply_markup=InlineKeyboardMarkup(keyboard))
        context.user_data['previous_message_id'] = new_message.message_id

    elif query.data == 'forecast':
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—è—Ü–µ–≤, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µü§ë")
        context.user_data['awaiting_forecast'] = True 

    elif query.data == 'exit':
        context.user_data.clear()
        await query.message.reply_text("–°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞! –ï—Å–ª–∏ –∑–∞—Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å, –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É /start.")
        await start(update, context)


async def handle_text_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_input = update.message.text
    

    if context.user_data.get('awaiting_date_period'):
        start_date, end_date = parse_period(user_input)
        if start_date != None and end_date != None:
            context.user_data['start_date'] = start_date
            context.user_data['end_date'] = end_date
            context.user_data.pop('awaiting_date_period')  
            
            new_message = await update.message.reply_text("–í–∞—Å –ø–æ–Ω—è–ª, –æ–¥–Ω—É –º–∏–Ω—É—Ç—É!")

            df = context.user_data.get('df')

            start_date = context.user_data.get('start_date')
            end_date = context.user_data.get('end_date')

            processed_df = cmal.filter_data_by_date(start_date, end_date, df)

            results = []
            image_path = 'output_spend_days.png'
            cmal.spend_days(processed_df, image_path)
            results.append(image_path)

            f1 = 'output_all_spend1.png'
            f2 = 'output_all_spend2.png'
            f3 = 'output_all_spend3.png'
            count = cmal.all_spending(processed_df, f1, f2, f3)
            if count == 2:
                results.append(f1)
                results.append(f2)
            else:
                results.append(f3)

            ff1 = 'output_all_repl1.png'
            ff2 = 'output_all_repl2.png'
            ff3 = 'output_all_repl3.png'
            count_1 = cmal.all_repl(processed_df, ff1, ff2, ff3)
            if count_1 == 2:
                results.append(ff1)
                results.append(ff2)
            else:
                results.append(ff3)

            im_cash = 'cashback.png'
            cmal.cashback(processed_df, 'images/patrik.jpg', im_cash)
            results.append(im_cash)

            media = []
            for image_path in results:
                with open(image_path, 'rb') as image_file:
                    media.append(InputMediaPhoto(image_file))

            await update.message.reply_media_group(media=media)

            for im in results:
                os.remove(im)


            new_message = await update.message.reply_text("–ù–∞–¥–µ—é—Å—å, –º–æ—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –≤–∞–º –ø–æ–º–æ–∂–µ—Ç!ü•∫")

            keyboard = [
                [InlineKeyboardButton("–†–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –¥—Ä—É–≥–æ–π –ø–µ—Ä–∏–æ–¥", callback_data='another_period')],
                [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='back')],
                [InlineKeyboardButton("–í—ã—Ö–æ–¥", callback_data='exit')]
            ]
            await new_message.reply_text("–ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?", reply_markup=InlineKeyboardMarkup(keyboard))
            context.user_data['previous_message_id'] = new_message.message_id

        else:
            await update.message.reply_text("–ù–µ –ø–æ–Ω—è–ª –í–∞—Å, –≤–≤–µ–¥–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –ø–æ-–¥—Ä—É–≥–æ–º—É, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ü•∫")
    
    
    elif context.user_data.get('awaiting_forecast'):
        try:
            count = int(user_input)
            df = context.user_data.get('df')
            f1 = "forecast.png"
            pred.pred_spend(df, count, f1)
            with open(f1, 'rb') as image_file:
                new_message = await update.message.reply_photo(photo=image_file)
            os.remove(f1)
            context.user_data.pop('awaiting_forecast')  

            keyboard = [
                [InlineKeyboardButton("–†–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –¥—Ä—É–≥–æ–π –ø–µ—Ä–∏–æ–¥", callback_data='another_forecast_period')],
                [InlineKeyboardButton("–ù–∞–∑–∞–¥", callback_data='back')],
                [InlineKeyboardButton("–í—ã—Ö–æ–¥", callback_data='exit')]
            ]
            await new_message.reply_text("–ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?", reply_markup=InlineKeyboardMarkup(keyboard))
            context.user_data['previous_message_id'] = new_message.message_id
        except ValueError:
            await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—è—Ü–µ–≤ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ).")
    else:
        await handle_date_input(update, context)  



async def handle_document(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    file = update.message.document
    logger.info(f"Received document: {file.file_name}")

    chat_id = update.message.chat.id
    instruction_message_id = context.user_data.get('instruction_message_id')


    if instruction_message_id:
        for message_id in context.user_data.get('message_ids', []):
            if message_id <= instruction_message_id:
                try:
                    await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

        context.user_data['message_ids'] = []

    try:
        file_obj = await file.get_file()
        file_data = await file_obj.download_as_bytearray()
        file_stream = BytesIO(file_data)
        file_stream.seek(0)

        df = pd.read_csv(file_stream, encoding='cp1251', sep=';')
        df = cmal.preparing(df)

        keyboard = [
            [InlineKeyboardButton("–ú–æ—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞", callback_data='analytics')],
            [InlineKeyboardButton("–•–æ—á—É —Å—ç–∫–æ–Ω–æ–º–∏—Ç—å", callback_data='save_money')],
            [InlineKeyboardButton("–°–∫–æ–ª—å–∫–æ —è –ø–æ—Ç—Ä–∞—á—É?", callback_data='forecast')],
            [InlineKeyboardButton("–ó–∞–≥—Ä—É–∑–∏—Ç—å –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª", callback_data='upload_new_file')],
            [InlineKeyboardButton("–í—ã—Ö–æ–¥", callback_data='exit')],
        ]
        new_message = await update.message.reply_text(f"–§–∞–π–ª {file.file_name} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω –∏ –ø—Ä–æ—á–∏—Ç–∞–Ω!", reply_markup=InlineKeyboardMarkup(keyboard))
        context.user_data['message_ids'] = [new_message.message_id]
        context.user_data['df'] = df
        context.user_data['filename'] = file.file_name

    except pd.errors.ParserError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}")
        await update.message.reply_text(f"–§–∞–π–ª {file.file_name} –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ—á–∏—Ç–∞–Ω: –ø—Ä–æ–±–ª–µ–º–∞ —Å —Ñ–æ—Ä–º–∞—Ç–æ–º –¥–∞–Ω–Ω—ã—Ö.")
    
    except UnicodeDecodeError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}")
        await update.message.reply_text(f"–§–∞–π–ª {file.file_name} –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ—á–∏—Ç–∞–Ω: –ø—Ä–æ–±–ª–µ–º–∞ —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª.")
    
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {e}")
        await update.message.reply_text(f"–§–∞–π–ª {file.file_name} –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª.")




async def handle_followup_actions(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    logger.info(f"Button clicked: {query.data}")

    chat_id = query.message.chat.id

    if query.data == 'another_period':
        previous_message_id = context.user_data.get('previous_message_id')
        if previous_message_id:
            try:
                await query.message.delete()
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä–∏–æ–¥, –∑–∞ –∫–æ—Ç–æ—Ä—ã–π –í–∞–º –Ω—É–∂–Ω–∞ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞üëÄ")
        context.user_data['awaiting_date_period'] = True

    elif query.data == 'another_forecast_period':
        previous_message_id = context.user_data.get('previous_message_id')
        if previous_message_id:
            try:
                await query.message.delete()
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")

        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—è—Ü–µ–≤ –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø—Ä–æ–≥–Ω–æ–∑–∞ü§ë")
        context.user_data['awaiting_forecast'] = True

    elif query.data == 'back':
        previous_message_id = context.user_data.get('previous_message_id')
        if previous_message_id:
            try:
                await query.message.delete()
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
        keyboard = [
            [InlineKeyboardButton("–ú–æ—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞", callback_data='analytics')],
            [InlineKeyboardButton("–•–æ—á—É —Å—ç–∫–æ–Ω–æ–º–∏—Ç—å", callback_data='save_money')],
            [InlineKeyboardButton("–°–∫–æ–ª—å–∫–æ —è –ø–æ—Ç—Ä–∞—á—É?", callback_data='forecast')],
            [InlineKeyboardButton("–ó–∞–≥—Ä—É–∑–∏—Ç—å –¥—Ä—É–≥–æ–π —Ñ–∞–π–ª", callback_data='upload_new_file')],
            [InlineKeyboardButton("–í—ã—Ö–æ–¥", callback_data='exit')],
        ]
        new_message = await query.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=InlineKeyboardMarkup(keyboard))
        context.user_data['message_ids'] = [new_message.message_id]

    elif query.data == 'exit':
        context.user_data.clear()
        await query.message.reply_text("–°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ—Ç–∞! –ï—Å–ª–∏ –∑–∞—Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å, –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–º–∞–Ω–¥—É /start.")
        await start(update, context)


async def handle_upload_new_file(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    logger.info(f"Button clicked: {query.data}")

    if query.data == 'upload_new_file':
        context.user_data.pop('df', None)
        context.user_data.pop('filename', None)
        caption = (
            "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –ø–æ–∫–∞ –Ω–µ –º–æ–≥—É –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —Ç–≤–æ–∏–º —Ñ–∏–Ω–∞–Ω—Å–∞–º –Ω–∞–ø—Ä—è–º—É—éüòî\n\n"
            "üîÜ–°–∫–∞—á–∞–π, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–≥—Ä—É–∑–∫—É –ø–æ –æ–ø–µ—Ä–∞—Ü–∏—è–º –∏–∑ —Ç–≤–æ–µ–≥–æ –º–æ–±–∏–ª—å–Ω–æ–≥–æ –±–∞–Ω–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ ***csv*** –∏ –ø—Ä–∏—à–ª–∏ –º–Ω–µ —Ñ–∞–π–ª –≤ —á–∞—ÇüîÜ\n\n"
            "–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª —Å–æ —Å–≤–æ–∏–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏:\n"
            "1Ô∏è‚É£–ó–∞–π–¥–∏—Ç–µ –≤ ***–ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –¢\-–±–∞–Ω–∫–∞*** –Ω–∞ —Å–≤–æ—ë–º ***–ü–ö***\n"
            "2Ô∏è‚É£–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤–æ –≤–∫–ª–∞–¥–∫—É ***–û–ø–µ—Ä–∞—Ü–∏–∏***\n"
            "3Ô∏è‚É£–ù–∞–π–¥–∏—Ç–µ —Å—Ç—Ä–µ–ª–æ—á–∫—É –¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏ –í–∞—à–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π\n"
            "4Ô∏è‚É£–°–∫–∞—á–∞–π—Ç–µ —Ñ–∞–π–ª –≤ —Ñ–æ—Ä–º–∞—Ç–µ ***csv***\n"
        )
        photos = [
            InputMediaPhoto(open('images/inst1.jpg', 'rb'), caption=caption, parse_mode='MarkdownV2'),
            InputMediaPhoto(open('images/inst2.jpg', 'rb')),
            InputMediaPhoto(open('images/inst3.jpg', 'rb'))
        ]

        await query.message.reply_media_group(media=photos)

async def main() -> None:
    application = ApplicationBuilder().token(TOKEN).build()

    application.add_handler(CommandHandler("start", start))

    application.add_handler(CallbackQueryHandler(button_click, pattern='start'))
    application.add_handler(CallbackQueryHandler(handle_post_upload, pattern='analytics'))
    application.add_handler(CallbackQueryHandler(handle_post_upload, pattern='save_money'))
    application.add_handler(CallbackQueryHandler(handle_post_upload, pattern='forecast'))
    application.add_handler(CallbackQueryHandler(handle_post_upload, pattern='exit'))
    application.add_handler(CallbackQueryHandler(handle_followup_actions, pattern='another_period'))
    application.add_handler(CallbackQueryHandler(handle_followup_actions, pattern='another_forecast_period'))
    application.add_handler(CallbackQueryHandler(handle_followup_actions, pattern='back'))
    application.add_handler(CallbackQueryHandler(handle_upload_new_file, pattern='upload_new_file'))

    application.add_handler(MessageHandler(filters.Document.ALL, handle_document))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_input))

    await application.run_polling()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())


